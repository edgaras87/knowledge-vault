---
title: '@Enumerated'
date: 2025-11-15
tags: 
  - database
  - jpa
  - hibernate
  - jakarta persistence 
  
summary: Comprehensive cheatsheet for the Jakarta Persistence `@Enumerated` annotation, detailing its purpose, parameters, and best practices for mapping Java enums to database columns.
aliases:
  - Jakarta Persistence — @Enumerated Cheatsheet

---



# Jakarta Persistence — `@Enumerated` Cheatsheet

Package: `jakarta.persistence.Enumerated`
Enum: `jakarta.persistence.EnumType`

`@Enumerated` tells JPA **how to store a Java enum in the database**:

* as a number (`0, 1, 2…`)
* or as a string (`"USER"`, `"ADMIN"`)

Pick wrong, and future-you cries when someone reorders enum constants.

---

## 0) Contents

| Section                                      | Description                                 | Link                                                           |
| -------------------------------------------- | ------------------------------------------- | -------------------------------------------------------------- |
| **1) All Parameters**                        | Signature of `@Enumerated`                  | → [All Parameters](#1-all-parameters)                          |
| **2) EnumType Options**                      | `STRING` vs `ORDINAL` explained             | → [EnumType Options](#2-enumtype-options)                      |
| **3) Basic Examples**                        | Simple field mapping with `@Enumerated`     | → [Basic Examples](#3-basic-examples)                          |
| **4) Why `STRING` is Almost Always Correct** | Future-proofing & migration safety          | → [Why STRING](#4-why-enumtypestring-is-almost-always-correct) |
| **5) Advanced Patterns**                     | Default values, optional enums, collections | → [Advanced Patterns](#5-advanced-patterns)                    |
| **6) Practical Rules**                       | What to memorize and repeat                 | → [Practical Rules](#6-practical-rules)                        |

---

## 1) All Parameters

`@Enumerated` is tiny:

```java
@Enumerated(EnumType.STRING)
private Role role;
```

Full signature:

```java
@Enumerated(
    EnumType value() default EnumType.ORDINAL
)
```

So:

* `value` → how to store the enum:

  * `EnumType.STRING`
  * `EnumType.ORDINAL`

Default is **ORDINAL** (the bad one).
We override that basically always.

---

## 2) EnumType Options

There are **only two**:

```java
public enum EnumType {
  ORDINAL, // bad in almost all cases
  STRING   // good
}
```

---

### 2.1 `EnumType.STRING`

Stores the enum name as text.

```java
public enum Role {
  USER, ADMIN, MODERATOR
}
```

Field:

```java
@Enumerated(EnumType.STRING)
@Column(nullable = false, length = 20)
private Role role;
```

Database:

| id | role        |
| -- | ----------- |
| 1  | 'USER'      |
| 2  | 'ADMIN'     |
| 3  | 'MODERATOR' |

**Pros:**

* Human-readable
* Stable when you reorder constants
* Safer for schema evolution
* Easier debugging and ad-hoc queries

**Cons:**

* Slightly more storage than an int
* That’s it. Storage is cheap; production bugs are not.

---

### 2.2 `EnumType.ORDINAL`

Stores the enum **index** (0-based position).

```java
public enum Role {
  USER, ADMIN, MODERATOR
}
```

Field:

```java
@Enumerated(EnumType.ORDINAL)
@Column(nullable = false)
private Role role;
```

Database:

| id | role |             |
| -- | ---- | ----------- |
| 1  | 0    | → USER      |
| 2  | 1    | → ADMIN     |
| 3  | 2    | → MODERATOR |

Now imagine you reorder the enum:

```java
public enum Role {
  ADMIN, USER, MODERATOR
}
```

Same DB values now mean:

| id | role | now interpreted as       |
| -- | ---- | ------------------------ |
| 1  | 0    | ADMIN (used to be USER)  |
| 2  | 1    | USER  (used to be ADMIN) |

You just silently corrupted every row’s meaning.

**Verdict:**
`ORDINAL` is a foot-gun unless you are extremely disciplined and never touch enum order.

---

## 3) Basic Examples

---

### 3.1 Simple enum mapping (`Role` as string)

```java
public enum Role {
  USER, ADMIN, MODERATOR
}

@Entity
@Table(name = "users")
public class UserEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(nullable = false, unique = true, length = 100)
  private String email;

  @Enumerated(EnumType.STRING)
  @Column(nullable = false, length = 20)
  private Role role;
}
```

Database:

```sql
CREATE TABLE users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  email VARCHAR(100) NOT NULL UNIQUE,
  role VARCHAR(20) NOT NULL
);
```

Rows:

| id | email                                   | role    |
| -- | --------------------------------------- | ------- |
| 1  | [u1@example.com](mailto:u1@example.com) | 'USER'  |
| 2  | [admin@ex.com](mailto:admin@ex.com)     | 'ADMIN' |

---

### 3.2 Optional enum field

```java
public enum Status {
  NEW, ACTIVE, SUSPENDED
}

@Entity
@Table(name = "accounts")
public class AccountEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Enumerated(EnumType.STRING)
  @Column(nullable = true, length = 20)
  private Status status;
}
```

Database:

| id | status |                   |
| -- | ------ | ----------------- |
| 1  | 'NEW'  |                   |
| 2  | NULL   | ← optional status |

---

### 3.3 Enum inside an embeddable

```java
public enum AddressType {
  HOME, WORK, OTHER
}

@Embeddable
public class Address {

  @Enumerated(EnumType.STRING)
  @Column(name = "address_type", length = 20, nullable = false)
  private AddressType type;

  @Column(name = "address_line", length = 200, nullable = false)
  private String line;
}
```

Used inside entity:

```java
@Entity
@Table(name = "customers")
public class CustomerEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Embedded
  private Address address;
}
```

---

## 4) Why `EnumType.STRING` is Almost Always Correct

### 4.1 Safe when enum changes

You add a new constant:

```java
public enum Role {
  USER, ADMIN, MODERATOR, SUPPORT
}
```

* `STRING` → old rows keep `"USER"`, `"ADMIN"`, `"MODERATOR"`, new ones may get `"SUPPORT"`. All good.
* `ORDINAL` → adding in the middle shifts indexes; old values are misinterpreted.

### 4.2 Easy to debug and query

With `STRING`:

```sql
SELECT * FROM users WHERE role = 'ADMIN';
```

With `ORDINAL`:

```sql
SELECT * FROM users WHERE role = 1;
-- today 1=ADMIN, tomorrow maybe 1=USER
```

### 4.3 Migration-friendly

Renaming enum constant?

* With `STRING`, you can write a migration that updates the text.
* With `ORDINAL`, names don’t exist in DB; you’re stuck juggling numbers.

**So the rule of thumb is simple:**

> Use `EnumType.STRING` unless you are forced not to.

---

## 5) Advanced Patterns

---

### 5.1 Enum + default value

You might not always set the enum explicitly in Java; DB can have a default.

```java
public enum Status {
  NEW, ACTIVE, SUSPENDED, DELETED
}

@Entity
@Table(name = "customers")
public class CustomerEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Enumerated(EnumType.STRING)
  @Column(
    nullable = false,
    length = 20,
    columnDefinition = "VARCHAR(20) DEFAULT 'NEW'"
  )
  private Status status = Status.NEW;
}
```

Gives both:

* Java default (`Status.NEW`)
* DB default (`'NEW'`) if column omitted in insert

---

### 5.2 Enum in collections (via separate table)

You don’t map `List<Enum>` directly to a single column.
You typically use a **join table or separate table**.

Example: user has multiple roles (still using string enum storage at the target).

```java
@Entity
@Table(name = "user_roles")
public class UserRoleEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @ManyToOne(fetch = FetchType.LAZY, optional = false)
  @JoinColumn(name = "user_id")
  private UserEntity user;

  @Enumerated(EnumType.STRING)
  @Column(name = "role", nullable = false, length = 20)
  private Role role;
}
```

That way the `role` column still uses `STRING`, but you can have many rows per user.

---

### 5.3 Enum in DTO vs Entity

In DTO:

```java
public enum RoleDto {
  USER, ADMIN
}

public record UserResponse(
  Long id,
  String email,
  RoleDto role
) {}
```

In entity:

```java
public enum Role {
  USER, ADMIN
}

@Entity
public class UserEntity {
  @Enumerated(EnumType.STRING)
  private Role role;
}
```

You can map between them with MapStruct later; for now you can often reuse the same enum in both layers.

---

## 6) Practical Rules

Here’s what you actually want to burn into muscle memory:

1. **Always explicitly specify STRING.**

   ```java
   @Enumerated(EnumType.STRING)
   ```

2. **Never rely on default (`ORDINAL`).**
   It’s like using `var` for everything and hoping it works out.

3. **Keep column length reasonable.**

   ```java
   @Column(length = 20)
   ```

4. **Enum names become data.**
   Renaming enum constants means writing DB migrations to update stored string values.

5. **Don’t use enums for values that change often.**
   Good enum examples:

   * role (`USER`, `ADMIN`)
   * account status (`NEW`, `ACTIVE`, `SUSPENDED`)
   * order status (`PENDING`, `PAID`, `CANCELLED`)

   Bad enum examples:

   * product categories that change daily
   * anything configured by business users in admin UI

6. **If you must use `ORDINAL`,** document it loudly and never reorder the enum.

