---
title: '@Id' 
date: 2025-11-15
tags: 
  - database
  - jpa
  - hibernate
  - jakarta persistence 
  
summary: Comprehensive cheatsheet for the Jakarta Persistence `@Id` annotation, detailing its purpose, usage, and best practices for defining primary keys in JPA entities.
aliases:
    - Jakarta Persistence — @Id Cheatsheet

---

# Jakarta Persistence — `@Id` Cheatsheet

Package: `jakarta.persistence.Id`

`@Id` marks a field (or getter) as the **primary key** of a JPA entity.
This is the identity JPA uses to:

* find a row
* track entity instances
* do updates/deletes
* manage the persistence context (1st-level cache)

No `@Id` → no entity. JPA refuses to play.

---

## 0) Contents

| Section                                          | Description                                        | Link                                                    |
| ------------------------------------------------ | -------------------------------------------------- | ------------------------------------------------------- |
| **1) Annotation Signature**                      | What `@Id` looks like at the API level             | → [Annotation Signature](#1-annotation-signature)       |
| **2) What `@Id` Actually Does**                  | Conceptual role: identity, PK, persistence context | → [What @Id Does](#2-what-id-actually-does)             |
| **3) `@Id` + `@GeneratedValue`**                 | How IDs actually get values                        | → [@Id + @GeneratedValue](#3-id--generatedvalue)        |
| **4) Natural IDs (No Generation)**               | When you don’t generate IDs (country codes, SKUs)  | → [Natural IDs](#4-natural-ids-no-generation)           |
| **5) Composite IDs (`@EmbeddedId`, `@IdClass`)** | Multi-column primary keys                          | → [Composite IDs](#5-composite-ids-embeddedid--idclass) |
| **6) Rules & Gotchas**                           | Do’s and don’ts around IDs                         | → [Rules & Gotchas](#6-rules--gotchas)                  |
| **7) Practical Patterns to Copy**                | Copy-paste-ready patterns for common setups        | → [Practical Patterns](#7-practical-patterns-to-copy)   |

---

## 1) Annotation Signature

`@Id` itself is very simple:

```java
import jakarta.persistence.Id;

@Id
private Long id;
```

* No parameters.
* No configuration.
* It **only** says: “this is the primary key of the entity”.

Everything about *how* IDs are generated is done with `@GeneratedValue` and friends, not `@Id`.

---

## 2) What `@Id` Actually Does

### 2.1 Marks the primary key column

Given:

```java
@Entity
@Table(name = "users")
public class UserEntity {

  @Id
  private Long id;

  // ...
}
```

JPA maps `id` as the **PRIMARY KEY** of `users`.

Typical DB schema:

```sql
CREATE TABLE users (
  id BIGINT NOT NULL,
  -- other columns...
  CONSTRAINT pk_users PRIMARY KEY (id)
);
```

Primary key implies:

* uniqueness
* non-null
* indexed lookup

---

### 2.2 Drives persistence context identity

In the persistence context (EntityManager / Hibernate Session), the primary key is how JPA knows which entity is which.

Example:

```java
UserEntity u1 = em.find(UserEntity.class, 1L);
UserEntity u2 = em.find(UserEntity.class, 1L);

u1 == u2;  // true (same instance, same persistence context)
```

Because:

* **Same entity type**
* **Same `@Id` value**
* → Same Java object instance in that context

---

### 2.3 Enables dirty checking

JPA tracks changes on **managed** entities. Identity is the anchor.

```java
UserEntity user = em.find(UserEntity.class, 5L);
user.setName("Alice");  // no explicit update

// on transaction commit:
-- Hibernate generates:
UPDATE users SET name = ? WHERE id = 5;
```

Without a stable primary key, dirty checking makes no sense.

---

### 2.4 Required for every entity

If you forget it:

```java
@Entity
public class UserEntity {
  private Long id; // no @Id → problem
}
```

Hibernate boots with:

> `No identifier specified for entity...`

Every `@Entity` must have **one and only one** `@Id` (composite IDs are handled via special mechanisms).

---

## 3) `@Id` + `@GeneratedValue`

`@Id` just says *which* field is the ID.
`@GeneratedValue` says *how it gets a value*.

Most common combo:

```java
@Entity
public class UserEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  // ...
}
```

Quick recap of strategies:

```java
@GeneratedValue(strategy = GenerationType.IDENTITY)  // auto-increment PK
@GeneratedValue(strategy = GenerationType.SEQUENCE)  // DB sequence (Postgres/Oracle)
@GeneratedValue(strategy = GenerationType.TABLE)     // table-based generator (rare)
@GeneratedValue(strategy = GenerationType.AUTO)      // provider decides
```

You already have a full `@GeneratedValue` cheatsheet — this is just the connection point:
**`@Id` says “this field is the key”, `@GeneratedValue` says “here’s how we get values for that key.”**

---

## 4) Natural IDs (No Generation)

Sometimes, the primary key is **not generated** — it’s something that already exists and is stable.

Example: country code.

```java
@Entity
@Table(name = "countries")
public class CountryEntity {

  @Id
  @Column(length = 2)
  private String code;  // "LT", "DE", "US"

  @Column(nullable = false, length = 100)
  private String name;
}
```

* No `@GeneratedValue`.
* You set `code` yourself.
* DB uses `code` as `PRIMARY KEY`.

Another example: SKU as business ID:

```java
@Entity
@Table(name = "products")
public class ProductEntity {

  @Id
  @Column(length = 50)
  private String sku; // "IPHONE-15-BLACK-128"

  // ...
}
```

**Guideline:**

* Use natural IDs **only when**:

  * they come from a stable domain concept
  * they never change
  * they are guaranteed unique
* Otherwise: use a generated surrogate key (`Long id`) and keep business identifiers separate.

---

## 5) Composite IDs (`@EmbeddedId` & `@IdClass`)

Sometimes the real PK is **multi-column**:

* `tenant_id + slug`
* `order_id + line_number`

JPA has two ways to model that.

### 5.1 `@EmbeddedId`

```java
@Embeddable
public class CategoryId {

  private Long tenantId;
  private String slug;

  // equals/hashCode based on both fields
}
```

```java
@Entity
@Table(name = "categories")
public class CategoryEntity {

  @EmbeddedId
  private CategoryId id;

  // ...
}
```

The **embedded ID class** holds the composite key.

---

### 5.2 `@IdClass`

```java
public class CategoryId implements Serializable {
  private Long tenantId;
  private String slug;
}
```

```java
@Entity
@IdClass(CategoryId.class)
@Table(name = "categories")
public class CategoryEntity {

  @Id
  private Long tenantId;

  @Id
  private String slug;

  // ...
}
```

**Practical advice for your level:**

* Avoid composite IDs if you can.
* Instead, use a generated `Long id` + unique index on `(tenant_id, slug)`:

  * simpler
  * easier mapping
  * easier FK relations

Composite IDs are more advanced and annoying for mapping and joins.

---

## 6) Rules & Gotchas

### 6.1 Don’t change the ID after persisting

Bad:

```java
UserEntity user = em.find(UserEntity.class, 1L);
user.setId(2L);  // huge nope
```

Primary key is identity. Changing it breaks:

* persistence context tracking
* caches
* FK relations

Treat IDs as **immutable after insert**.

---

### 6.2 Don’t use business logic on raw ID values

Example of leaky logic (bad):

```java
if (user.getId() < 1000) {
  // special case for early users
}
```

IDs are internal technical identities.
Business rules should use domain fields:

* `registrationDate`
* `role`
* `status`
* `tier`

Not “magic ID ranges”.

---

### 6.3 Equals/hashCode with `@Id`

Common patterns:

#### Entity identity based on ID (after persistence)

```java
@Override
public boolean equals(Object o) {
  if (this == o) return true;
  if (!(o instanceof UserEntity other)) return false;
  return id != null && id.equals(other.id);
}

@Override
public int hashCode() {
  return 31;
}
```

Better: let Lombok / your architecture pattern handle this later — for now, don’t obsess. Just don’t base equality on *all* fields.

---

### 6.4 ID type choice

Most common: `Long`.

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

Others:

* `UUID` with provider generator (`@UuidGenerator`)
* `String` for natural IDs
* `Integer` for small ranges

Your default: **`Long`** is the safe, boring, excellent choice.

---

## 7) Practical Patterns to Copy

### 7.1 Classic Spring Boot + JPA setup (MySQL/Postgres, simple)

```java
@Entity
@Table(name = "categories")
public class CategoryEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;

  @Column(nullable = false, length = 100)
  private String name;

  @Column(nullable = false, length = 100, unique = true)
  private String slug;

  // ...
}
```

---

### 7.2 Sequence-based ID (good for Postgres)

```java
@Entity
@Table(name = "categories")
public class CategoryEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "category_seq")
  @SequenceGenerator(
      name = "category_seq",
      sequenceName = "category_seq",
      allocationSize = 50
  )
  private Long id;

  // ...
}
```

---

### 7.3 UUID primary key

(Needs Hibernate annotations, not pure JPA, but very common.)

```java
import org.hibernate.annotations.UuidGenerator;

@Entity
@Table(name = "customers")
public class CustomerEntity {

  @Id
  @GeneratedValue
  @UuidGenerator
  private java.util.UUID id;

  // ...
}
```

---

### 7.4 Natural key (`code`) as ID

```java
@Entity
@Table(name = "countries")
public class CountryEntity {

  @Id
  @Column(length = 2)
  private String code; // "LT", "DE"

  @Column(nullable = false, length = 100)
  private String name;
}
```

---

### 7.5 Surrogate `id` + unique business field

This is the combo you’ll probably use a lot:

```java
@Entity
@Table(
  name = "categories",
  indexes = @Index(
    name = "uk_categories_slug",
    columnList = "slug",
    unique = true
  )
)
public class CategoryEntity {

  @Id
  @GeneratedValue(strategy = GenerationType.IDENTITY)
  private Long id;  // technical ID

  @Column(nullable = false, length = 100, unique = true)
  private String slug; // business identifier

  // ...
}
```

* `id` → internal identity, FK target, JPA tracking
* `slug` → external/business identity (used in URLs, etc.)

This separation is very healthy.
