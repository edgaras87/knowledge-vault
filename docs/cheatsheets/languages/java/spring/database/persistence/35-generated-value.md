---
title: '@GeneratedValue' 
date: 2025-11-15
tags: 
  - database
  - jpa
  - hibernate
  - jakarta persistence 
  
summary: Comprehensive cheatsheet for the Jakarta Persistence `@GeneratedValue` annotation, detailing its attributes and usage for defining primary key generation strategies in JPA.
aliases:
    - Jakarta Persistence — @GeneratedValue Cheatsheet

---

# Jakarta Persistence — `@GeneratedValue` Cheatsheet

Package: `jakarta.persistence.GeneratedValue`
Enum: `jakarta.persistence.GenerationType`

`@GeneratedValue` tells JPA **how** the primary key (annotated with `@Id`) receives its value.

The annotation does *not* define *which* field is the ID — that’s `@Id`.
This one defines *who generates the ID* and *using what mechanism*.

---

## 0) Contents

| Section                                                     | Description                               | Link                                                            |
| ----------------------------------------------------------- | ----------------------------------------- | --------------------------------------------------------------- |
| **1) All Parameters**                                       | The full annotation signature             | → [All Parameters](#1-all-parameters)                           |
| **2) Overview of Strategies**                               | What AUTO, IDENTITY, SEQUENCE, TABLE mean | → [Overview of Strategies](#2-overview-of-strategies)           |
| **3) Strategy Details & Examples**                          | Deep explanations + DB-level behavior     | → [Strategy Details](#3-strategy-details--examples)             |
| **3.1 IDENTITY**                                            | Auto-increment PK (MySQL, Postgres, etc.) | → [IDENTITY](#31-generationtypeidentity)                        |
| **3.2 SEQUENCE**                                            | DB sequence-based IDs (Postgres/Oracle)   | → [SEQUENCE](#32-generationtypesequence)                        |
| **3.3 TABLE**                                               | Table-based generator (legacy, slow)      | → [TABLE](#33-generationtypetable)                              |
| **3.4 AUTO**                                                | Hibernate decides                         | → [AUTO](#34-generationtypeauto)                                |
| **4) Generators (`@SequenceGenerator`, `@TableGenerator`)** | How custom generators work                | → [Generators](#4-generators-sequencegenerator--tablegenerator) |
| **5) UUID Generation (Hibernate)**                          | Modern UUID identifiers                   | → [UUID Generation](#5-uuid-generation-hibernate-specific)      |
| **6) Requirements & Gotchas**                               | What to avoid, what to memorize           | → [Requirements & Gotchas](#6-requirements--gotchas)            |
| **7) Practical Patterns**                                   | Realistic patterns you will use           | → [Practical Patterns](#7-practical-patterns)                   |

---

## 1) All Parameters

`@GeneratedValue` is small:

```java
@GeneratedValue(
    strategy = GenerationType.AUTO,
    generator = ""        // optional named generator
)
```

* **`strategy`** — the generation mechanism
  (`AUTO`, `IDENTITY`, `SEQUENCE`, `TABLE`)
* **`generator`** — name of a custom generator
  (used with `@SequenceGenerator`, `@TableGenerator`, or Hibernate-specific generators)

---

## 2) Overview of Strategies

| Strategy     | Where used                           | Behavior                         | Notes             |
| ------------ | ------------------------------------ | -------------------------------- | ----------------- |
| **IDENTITY** | MySQL, MariaDB, Postgres, SQL Server | DB auto-increment column         | Simple, reliable  |
| **SEQUENCE** | Postgres, Oracle, DB2                | DB sequence object generates IDs | Best for Postgres |
| **TABLE**    | Any DB                               | Custom table holds next ID       | Slow, legacy      |
| **AUTO**     | Anywhere                             | Hibernate chooses best strategy  | OK for prototypes |

The two you’ll use 99% of the time:

* `IDENTITY`
* `SEQUENCE`

---

## 3) Strategy Details & Examples

---

### 3.1 `GenerationType.IDENTITY`

DB-generated auto-increment.

Good for: **MySQL**, MariaDB, SQLServer, *and even Postgres if you want simplicity*.

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

Database column:

```sql
id BIGINT GENERATED BY DEFAULT AS IDENTITY
```

**How it works:**

* Hibernate executes `INSERT`
* DB assigns ID automatically
* Hibernate reads back the ID

**Pros**

* Zero configuration
* Very simple
* Works with most DBs

**Cons**

* Harder to batch inserts efficiently
* Hibernate cannot pre-allocate IDs

---

### 3.2 `GenerationType.SEQUENCE`

DB sequence object generates IDs.
Best for: **Postgres** / Oracle.

```java
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "user_seq")
@SequenceGenerator(
  name = "user_seq",
  sequenceName = "user_id_seq",
  allocationSize = 50
)
private Long id;
```

DB object:

```sql
CREATE SEQUENCE user_id_seq START 1 INCREMENT BY 1;
```

**Pros**

* Best performance (ID preallocation)
* Great for batching
* No insert-before-ID-fetch roundtrip

**Cons**

* Requires sequence support
* Slightly more configuration

**Rule:**
If using Postgres and you care about throughput → **use SEQUENCE**.

---

### 3.3 `GenerationType.TABLE`

IDs stored in a special table.
Portable, but slow and rarely needed.

```java
@Id
@GeneratedValue(strategy = GenerationType.TABLE, generator = "order_gen")
@TableGenerator(
  name = "order_gen",
  table = "id_gen",
  pkColumnName = "gen_name",
  valueColumnName = "gen_value",
  pkColumnValue = "order_id",
  allocationSize = 20
)
private Long id;
```

Table:

```sql
CREATE TABLE id_gen (
  gen_name VARCHAR(64) PRIMARY KEY,
  gen_value BIGINT
);
```

**Only use if** the target DB has no sequences and you need cross-platform portability.

---

### 3.4 `GenerationType.AUTO`

Hibernate chooses a strategy based on the DB dialect.

```java
@Id
@GeneratedValue(strategy = GenerationType.AUTO)
private Long id;
```

Hibernate picks:

* Postgres → `SEQUENCE`
* MySQL → `TABLE` or `IDENTITY` depending on version
* H2 → `SEQUENCE`

**Good for:** prototypes
**Not good for:** predictable production behavior

---

## 4) Generators (`@SequenceGenerator` & `@TableGenerator`)

---

### `@SequenceGenerator`

```java
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "prod_seq")
@SequenceGenerator(
  name = "prod_seq",
  sequenceName = "product_id_seq",
  allocationSize = 50
)
```

Parameters:

* `name` — logical generator name
* `sequenceName` — DB sequence name
* `allocationSize` — how many IDs Hibernate reserves per round-trip

**Pro tip:**
`allocationSize = 50` or `100` gives great performance.

---

### `@TableGenerator`

```java
@GeneratedValue(strategy = GenerationType.TABLE, generator = "order_gen")
@TableGenerator(
  name = "order_gen",
  table = "id_gen",
  pkColumnName = "gen_name",
  valueColumnName = "gen_value",
  pkColumnValue = "order_id",
  allocationSize = 20
)
```

Parameters match the table schema.
Used almost nowhere in modern systems.

---

## 5) UUID Generation (Hibernate-specific)

Not pure JPA, but extremely useful.

```java
import org.hibernate.annotations.UuidGenerator;

@Id
@GeneratedValue
@UuidGenerator
private UUID id;
```

**Why use UUID?**

* No DB round-trip for ID
* Good for distributed systems
* Safe for sharding / microservices
* Good for external/public identifiers

Tradeoff:

* Larger indices than BIGINT
* Slightly slower index operations

---

## 6) Requirements & Gotchas

### 6.1 Don’t change ID after persistence

Bad:

```java
entity.setId(10L);
```

Identity must be immutable.

---

### 6.2 ID type must match generation strategy

* Sequence/identity → `Long`, `Integer`, `Long` preferred
* UUID → with `@UuidGenerator`
* Natural ID → `String` or other stable type

---

### 6.3 Avoid composite ID + `@GeneratedValue`

Composite keys and auto-generated keys don’t mix.
If you need multi-column uniqueness → use unique indexes, not composite PK.

---

### 6.4 Don’t rely on ID ordering for business rules

IDs are technical identifiers, not sortable business fields.

---

## 7) Practical Patterns

---

### 7.1 The Spring Boot default (MySQL / Postgres simple case)

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;
```

---

### 7.2 The “best-practice Postgres” setup

```java
@Id
@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "category_seq")
@SequenceGenerator(
  name = "category_seq",
  sequenceName = "category_seq",
  allocationSize = 50
)
private Long id;
```

---

### 7.3 UUID identity for public-facing entities

```java
@Id
@GeneratedValue
@UuidGenerator
private UUID id;
```

Great for user-visible IDs in URLs.

---

### 7.4 Natural ID (no generation)

```java
@Id
@Column(length = 2)
private String code; // "LT", "DE", "FR"
```

---

### 7.5 Surrogate ID + business unique field (recommended pattern)

```java
@Id
@GeneratedValue(strategy = GenerationType.IDENTITY)
private Long id;

@Column(nullable = false, unique = true, length = 100)
private String slug;    // natural/business identifier
```

This gives you:

* Simple internal identity
* Safe external identity

Perfect for categories, users, products, etc.
