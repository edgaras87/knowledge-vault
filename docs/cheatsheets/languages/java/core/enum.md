---
title: enum
date: 2025-11-15
tags: 
  - java
  - language
  - cheatsheet 

summary: Comprehensive cheatsheet for Java `enum`, covering syntax, usage patterns, methods, persistence, JSON serialization, and best practices.
aliases:
  - Java — enum Cheatsheet

---

# Java `enum` — Practical Cheatsheet

## Content

- [0. What is an `enum`?](#0-what-is-an-enum)
- [1. Basic syntax & rules](#1-basic-syntax--rules)
- [2. When to use an enum](#2-when-to-use-an-enum)
- [3. Enums with fields & constructors](#3-enums-with-fields--constructors)
- [4. Methods and behavior on enums](#4-methods-and-behavior-on-enums)
- [5. Static helpers: fromString / fromCode](#5-static-helpers-fromstring--fromcode)
- [6. Switch and pattern matching with enums](#6-switch-and-pattern-matching-with-enums)
- [7. EnumSet and EnumMap](#7-enumset-and-enummap)
- [8. Enums implementing interfaces (strategy pattern)](#8-enums-implementing-interfaces-strategy-pattern)
- [9. Enums and persistence (JPA / DB)](#9-enums-and-persistence-jpa--db)
- [10. Enums and JSON (Jackson / Spring)](#10-enums-and-json-jackson--spring)
- [11. Common pitfalls & anti-patterns](#11-common-pitfalls--anti-patterns)
- [12. Mental checklist](#12-mental-checklist)

---

## 0. What is an `enum`?

An **enum** is a special class that represents a fixed set of constants.

Examples:

- days of the week: `MONDAY`, `TUESDAY`, …  
- order status: `NEW`, `PAID`, `SHIPPED`, `CANCELLED`  
- user roles: `USER`, `ADMIN`, `MODERATOR`

```java
public enum Role {
    USER,
    ADMIN,
    MODERATOR
}

// usage
Role r = Role.ADMIN;
System.out.println(r.name());   // "ADMIN"
System.out.println(r.ordinal()); // 1 (0-based)
```

Key idea: use enums to model **domain vocabulary** as strongly typed values.

---

## 1. Basic syntax & rules

### 1.1 Simple declaration

```java
public enum Status {
    NEW,
    IN_PROGRESS,
    DONE
}
```

Rules / properties:

* Enums are implicitly `final` (cannot extend them).
* Enums implicitly extend `java.lang.Enum<Status>`.
* You can add methods, fields, constructors.
* You cannot instantiate them directly (`new Status()` is illegal).
* Instances are singletons per constant (one `Status.DONE` in JVM).

### 1.2 Accessing constants

```java
Status s = Status.NEW;

Status s2 = Status.valueOf("DONE"); // throws IllegalArgumentException if name invalid
Status[] all = Status.values();     // array of all constants
```

`values()` is generated by the compiler for each enum.

---

## 2. When to use an enum

Good use cases:

* **Finite, well-known set** of options.
* Values represent **domain concepts**.
* You want **type safety** instead of strings or magic ints.
* You switch on them often (e.g., branching logic per status).

Examples:

```java
public enum OrderStatus {
    NEW,
    PAID,
    SHIPPED,
    CANCELLED
}

public enum Currency {
    EUR,
    USD,
    GBP
}
```

Avoid enums when:

* Values change frequently at runtime (e.g., dynamic lookup tables).
* Values are loaded from DB and can be changed by users/admins.
* You need thousands of values (enums are not good as big data tables).

In those cases, use DB tables or config + normal classes.

---

## 3. Enums with fields & constructors

Enums can have fields and constructors. The constructor is always `private` or package-private.

```java
public enum HttpStatus {
    OK(200, "OK"),
    CREATED(201, "Created"),
    BAD_REQUEST(400, "Bad Request"),
    NOT_FOUND(404, "Not Found");

    private final int code;
    private final String reason;

    HttpStatus(int code, String reason) {
        this.code = code;
        this.reason = reason;
    }

    public int code() {
        return code;
    }

    public String reason() {
        return reason;
    }
}

// usage
HttpStatus s = HttpStatus.NOT_FOUND;
System.out.println(s.code());   // 404
System.out.println(s.reason()); // "Not Found"
```

Typical patterns:

* **code + label**: numeric code plus human-readable label.
* **short key + description** for UI.
* **mapping to external system codes**.

---

## 4. Methods and behavior on enums

Enums are full classes; you can add methods.

```java
public enum Priority {
    LOW(1),
    MEDIUM(5),
    HIGH(10);

    private final int weight;

    Priority(int weight) {
        this.weight = weight;
    }

    public boolean isHigherThan(Priority other) {
        return this.weight > other.weight;
    }
}

// usage
Priority p = Priority.HIGH;
System.out.println(p.isHigherThan(Priority.MEDIUM)); // true
```

You can also override `toString()`:

```java
public enum Role {
    USER,
    ADMIN;

    @Override
    public String toString() {
        return name().toLowerCase(); // "user", "admin"
    }
}
```

---

## 5. Static helpers: fromString / fromCode

In real systems you often need to map from:

* request strings → enum
* DB code → enum

Use **static factory methods** instead of leaking `valueOf` everywhere.

```java
public enum CountryCode {
    LT("LT", "Lithuania"),
    DE("DE", "Germany"),
    FR("FR", "France");

    private final String code;
    private final String label;

    CountryCode(String code, String label) {
        this.code = code;
        this.label = label;
    }

    public String code() {
        return code;
    }

    public String label() {
        return label;
    }

    public static Optional<CountryCode> fromCode(String code) {
        return Arrays.stream(values())
                     .filter(c -> c.code.equalsIgnoreCase(code))
                     .findFirst();
    }
}

// usage
CountryCode.fromCode("de")
           .orElseThrow(() -> new IllegalArgumentException("Unknown code"));
```

You can also provide a `fromCodeOrDefault` helper.

---

## 6. Switch and pattern matching with enums

### 6.1 Classic switch

```java
public String labelFor(Status status) {
    return switch (status) {
        case NEW        -> "New";
        case IN_PROGRESS -> "In Progress";
        case DONE       -> "Completed";
    };
}
```

Using the newer `switch` expression style (Java 14+).

### 6.2 Behavior inside enum vs giant switch

If logic belongs **to the enum** conceptually, prefer putting behavior inside the enum instead of `switch`ing outside:

```java
public enum TaxRate {
    STANDARD(0.21),
    REDUCED(0.09),
    ZERO(0.0);

    private final double rate;

    TaxRate(double rate) {
        this.rate = rate;
    }

    public BigDecimal applyTo(BigDecimal net) {
        return net.multiply(BigDecimal.valueOf(1.0 + rate));
    }
}
```

This keeps domain rules close to the vocabulary.

---

## 7. EnumSet and EnumMap

Enums pair nicely with specialized collections:

### 7.1 EnumSet

Efficient set of enum constants.

```java
EnumSet<Role> adminRoles = EnumSet.of(Role.ADMIN, Role.MODERATOR);

if (adminRoles.contains(currentRole)) {
    // allow admin action
}
```

Benefits:

* Very compact representation (bitset).
* Fast operations (union, intersection).

### 7.2 EnumMap

Map keyed by enum, faster and lighter than `HashMap<Enum,…>`.

```java
EnumMap<Priority, Integer> limits = new EnumMap<>(Priority.class);
limits.put(Priority.LOW, 10);
limits.put(Priority.MEDIUM, 50);
limits.put(Priority.HIGH, 100);
```

Good for configuration-style mappings by enum key.

---

## 8. Enums implementing interfaces (strategy pattern)

Enums can implement interfaces, which allows **per-constant behavior**.

```java
public interface DiscountPolicy {
    BigDecimal apply(BigDecimal amount);
}

public enum DiscountType implements DiscountPolicy {
    NONE {
        @Override
        public BigDecimal apply(BigDecimal amount) {
            return amount;
        }
    },
    PERCENT_10 {
        @Override
        public BigDecimal apply(BigDecimal amount) {
            return amount.multiply(BigDecimal.valueOf(0.9));
        }
    },
    FIXED_5 {
        @Override
        public BigDecimal apply(BigDecimal amount) {
            return amount.subtract(BigDecimal.valueOf(5)).max(BigDecimal.ZERO);
        }
    };
}
```

Usage:

```java
DiscountType type = DiscountType.PERCENT_10;
BigDecimal finalPrice = type.apply(BigDecimal.valueOf(100));
```

This pattern is useful when behavior **depends on enum constant** and you want to avoid `switch` in many places.

---

## 9. Enums and persistence (JPA / DB)

### 9.1 Basic JPA mapping

By default:

```java
@Entity
public class User {

    @Id
    private Long id;

    @Enumerated(EnumType.STRING)
    private Role role;
}
```

Strong recommendation: **always use `EnumType.STRING`**, not `ORDINAL`.

* `STRING`: writes `"USER"`, `"ADMIN"` to DB.
  Renaming constants is still dangerous, but reordering them is safe.
* `ORDINAL`: writes `0`, `1`, `2` based on position.
  Reordering or inserting constants breaks all existing data.

### 9.2 Mapping to custom code

Sometimes DB stores codes like `U`, `A` instead of full names.

Use a converter:

```java
public enum Role {
    USER("U"),
    ADMIN("A");

    private final String code;

    Role(String code) {
        this.code = code;
    }

    public String code() { return code; }

    public static Role fromCode(String code) {
        return Arrays.stream(values())
                     .filter(r -> r.code.equals(code))
                     .findFirst()
                     .orElseThrow(() -> new IllegalArgumentException("Unknown role code: " + code));
    }
}

@Converter(autoApply = true)
public class RoleConverter implements AttributeConverter<Role, String> {

    @Override
    public String convertToDatabaseColumn(Role role) {
        return role == null ? null : role.code();
    }

    @Override
    public Role convertToEntityAttribute(String dbData) {
        return dbData == null ? null : Role.fromCode(dbData);
    }
}
```

---

## 10. Enums and JSON (Jackson / Spring)

### 10.1 Default behavior

By default, Jackson serializes enums as their `name()`:

```java
public enum Role {
    USER,
    ADMIN
}

// JSON: "USER"
```

For fields:

```java
public record UserResponse(String username, Role role) { }
```

JSON:

```json
{
  "username": "alice",
  "role": "ADMIN"
}
```

### 10.2 Custom JSON values

Use `@JsonValue` on a method/field to control JSON representation:

```java
public enum Role {
    USER("user"),
    ADMIN("admin");

    private final String json;

    Role(String json) {
        this.json = json;
    }

    @JsonValue
    public String json() {
        return json;
    }
}
```

JSON will contain `"user"` / `"admin"` instead of `"USER"` / `"ADMIN"`.

To customize deserialization, add a `@JsonCreator` factory:

```java
public enum Role {
    USER("user"),
    ADMIN("admin");

    private final String json;

    Role(String json) {
        this.json = json;
    }

    @JsonValue
    public String json() {
        return json;
    }

    @JsonCreator
    public static Role fromJson(String value) {
        return Arrays.stream(values())
                     .filter(r -> r.json.equalsIgnoreCase(value))
                     .findFirst()
                     .orElseThrow(() -> new IllegalArgumentException("Unknown role: " + value));
    }
}
```

---

## 11. Common pitfalls & anti-patterns

1. **Using `ordinal()` in business logic**

   ```java
   if (priority.ordinal() > other.ordinal()) { ... } // fragile
   ```

   Reordering constants breaks logic. Use explicit fields (e.g. `weight`) instead.

2. **Persisting ordinal values in DB**

   * Reordering or inserting constants corrupts data.
   * Always prefer `EnumType.STRING` or explicit converters.

3. **Enums as dynamic lookup tables**

   * If values are changed by admins or live in DB, they are not enums.
   * Use a table + normal entity or value object.

4. **Too many responsibilities inside enum**

   * Some behavior belongs near the enum, some belongs in services.
   * If enum grows huge with many methods, consider moving behavior out.

5. **Using enums where a simple boolean or int would do**

   * If there are only two states and they are not domain concepts, a boolean might be clearer.
   * If the states are meaningful (`ENABLED`, `DISABLED`), enum can still help with readability.

---

## 12. Mental checklist

Before creating / using an enum:

1. Is the set of values **finite and stable**?
2. Does each value represent a **domain concept**, not a low-level detail?
3. Will you benefit from **type safety** instead of passing strings/ints?
4. Do you know how it will be **serialized** (DB / JSON / logs)?
5. Do you avoid depending on **ordinal position** in logic or persistence?
6. Is this not a dynamic, user-configurable list?

If the answers are mostly “yes” → enum is appropriate.

Enums are your way of teaching the compiler your domain vocabulary.     
Use them where names matter and the list stays relatively stable.

